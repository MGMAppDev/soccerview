# SOCCERVIEW GUARDRAILS

> **âš ï¸ MANDATORY READING â€” DO NOT SKIP**
>
> **What this document is:** A permanent engineering rulebook for the SoccerView project. Every rule here was learned the hard way and exists to prevent catastrophic mistakes. These are non-negotiable constraints.
>
> **How Claude Code must treat this document:**
> 1. Read this file IN FULL before taking ANY action in a session.
> 2. Treat every rule as an absolute constraint â€” not a suggestion.
> 3. If a proposed action conflicts with any rule below, STOP and discuss with the user before proceeding.
> 4. This document is append-only. Rules may be ADDED but never removed or weakened.
> 5. Do not reference this document's existence or quote it back to the user. Just follow it silently.
> 6. Do not use this document to track session history, progress, or completed work. It is purely prescriptive.

---

## 1. UI PROTECTION

The UI represents 100+ hours of manual QA and polish. It is the most fragile and expensive part of the project.

- **NEVER** touch `.tsx` files without explicit user approval.
- **NEVER** batch multiple UI changes together. One change â†’ verify â†’ next change.
- **NEVER** change component structure, styling, spacing, or layouts.
- If the UI shows wrong data, fix the **data source** â€” not the UI.
- Data layer fixes only. The UI must receive the **exact same schema** it already expects.
- Test one page at a time. Verify it works before touching the next.

---

## 2. V2 ARCHITECTURE

All data must flow through the established pipeline. No shortcuts.

```
Staging Tables â†’ dataQualityEngine â†’ Normalizers â†’ Canonical Registries â†’ Production Tables
```

- **NEVER** bypass normalizers with ad-hoc fuzzy matching scripts.
- **NEVER** write directly to `teams_v2` or `matches_v2`. Use staging tables first.
- **NEVER** use deprecated legacy scripts without checking if a V2 replacement exists.
- **NEVER** use the Supabase client for bulk operations. Use `pg Pool` with direct SQL.
- **NEVER** process records row-by-row. Use bulk SQL (`CASE`, `unnest`, `INSERT...SELECT`).
- Always use `canonical_teams`, `canonical_events`, `canonical_clubs` for deduplication.
- Always use `teamNormalizer.js`, `eventNormalizer.js`, `matchNormalizer.js` for standardization.
- **NEVER** create tournaments or leagues with generic names ("Event 12093", "GotSport", bare numbers). Use `isGeneric()` from `resolveEventName.cjs` to validate. Return NULL and skip event creation instead (Session 91).
- Speed benchmark: 1,000+ records/second is the minimum expectation. If slower, refactor.

### Canonical Registry Health

Before any deduplication work, verify coverage:

```sql
SELECT COUNT(*) FROM teams_v2;
SELECT COUNT(*) FROM canonical_teams;
-- canonical_teams should be ~90%+ of teams_v2
```

If `canonical_teams` is below 50% of `teams_v2`, the V2 deduplication architecture **cannot function**. Run `populateCanonicalTeams.cjs --execute` before proceeding.

---

## 3. DATA INTEGRITY

Data integrity is the #1 priority across all decisions. One team, one truth, everywhere in the app.

- **NEVER** use `?? 0` or `|| 0` for scores. This destroys NULL values that represent scheduled/future matches.
- **NEVER** use `COALESCE(score, 0)` in SQL views.
- **NEVER** mark events as processed if `matches.length === 0`.
- **NEVER** assume team names are consistent across events. The same team may appear under different names.
- **NEVER** use `source_match_key` for match uniqueness. Use semantic key: `(match_date, home_team_id, away_team_id)`.
- Always preserve `NULL` scores for scheduled/future matches.
- Checkpoint logic: only mark an event processed **inside** a block that confirmed matches were found.
- Run team deduplication after any multi-source data import.

### Match Uniqueness (Session 85)

Matches are uniquely identified by **semantic key** using SoccerView Team IDs:

```sql
-- UNIQUE constraint on matches_v2
UNIQUE (match_date, home_team_id, away_team_id)
```

**Why NOT source_match_key?**
- Same match can come from multiple sources with different source keys
- V1 migration created duplicates because V1 had different keys than V2 scrapers
- Semantic key = same teams, same date = same match (regardless of source)

**Pipeline ON CONFLICT pattern:**
```sql
INSERT INTO matches_v2 (...)
ON CONFLICT (match_date, home_team_id, away_team_id) DO UPDATE SET
  home_score = CASE WHEN matches_v2.home_score IS NOT NULL THEN matches_v2.home_score ELSE EXCLUDED.home_score END,
  -- Keep existing scores, fill in missing ones
```

**source_match_key purpose:** Audit trail only. Tracks which source provided the data.

### Match Deletion - ALWAYS Soft Delete (Session 86)

**CRITICAL:** Match deduplication MUST use soft delete, not hard delete.

```sql
-- âŒ WRONG â€” Data is lost permanently
DELETE FROM matches_v2 WHERE id = ANY($1);

-- âœ… CORRECT â€” Data is preserved for recovery
UPDATE matches_v2
SET deleted_at = NOW(),
    deletion_reason = 'Semantic duplicate of ' || $2
WHERE id = ANY($1);
```

**Why this matters:**
- Session 85 hard-deleted 9,160 matches, causing ALL match history to disappear
- "Duplicate" matches are often the SAME real-world match from different sources
- Soft delete preserves data for recovery while excluding from active queries
- Always include `WHERE deleted_at IS NULL` in active match queries

**Recovery:** Soft-deleted data can be recovered by setting `deleted_at = NULL`.

---

## 4. UNIVERSAL CODE PATTERNS

### Division Detection
```javascript
// âœ… CORRECT â€” dash is optional
/U-?\d{1,2}\b|20[01]\d/i

// âŒ WRONG â€” requires dash, misses "U12"
/U-\d+/
```

### Age Group Extraction
```javascript
// âœ… CORRECT â€” handles "U12", "U-12", "U 12"
/\bU[-\s]?(\d{1,2})\b/i

// âŒ WRONG â€” only matches "U12"
/u(\d{1,2})/
```

### NULL Score Preservation
```javascript
// âœ… CORRECT â€” preserves scheduled matches
home_score: hasValidScores ? homeScore : null

// âŒ WRONG â€” turns scheduled matches into 0-0 results
home_score: homeScore ?? 0
```

### Duplicate Club Prefix Detection
```sql
-- GotSport rankings sometimes produce "One FC One FC B2015 PRE-MLS"
-- Detect with:
WHERE split_part(canonical_name, ' ', 1) = split_part(canonical_name, ' ', 2)
   OR (split_part(canonical_name, ' ', 1) = split_part(canonical_name, ' ', 3)
       AND split_part(canonical_name, ' ', 2) = split_part(canonical_name, ' ', 4))
```

### Bulk Operations
```javascript
// âŒ WRONG â€” takes hours for 100K+ records
for (const team of teams) {
  await supabase.from('teams_v2').update({ elo: newElo }).eq('id', team.id);
}

// âœ… CORRECT â€” takes seconds for 100K+ records
const pool = new Pool({ connectionString: process.env.DATABASE_URL });
await pool.query(`
  WITH merge_data AS (
    SELECT unnest($1::uuid[]) as id, unnest($2::int[]) as elo
  )
  UPDATE teams_v2 t SET elo_rating = md.elo
  FROM merge_data md WHERE t.id = md.id
`, [ids, elos]);
```

---

## 5. THREE-LAYER LIFECYCLE

Every fix must be verified across all three layers before it can be considered complete.

```
Layer 1 (Intake)        â†’ Layer 2 (Processing)       â†’ Layer 3 (Presentation)
Scrapers / Adapters     â†’ Validation / Normalizers    â†’ Views / App UI
```

Before closing ANY fix, ask: **Did this change propagate correctly through all three layers?**

Run the lifecycle audit to verify: `node scripts/maintenance/auditDataLifecycle.js`

---

## 6. TWO-PHASE DATA COLLECTION

| Phase | Script | Purpose | Writes To |
|-------|--------|---------|-----------|
| **1. Team Scraper** | `runTeamScraperBatch.js` | Discover event IDs | `event_registry` |
| **2. Event Scraper** | `runEventScraperBatch.js` | Get actual match scores | `match_results` |

Phase 1 must complete before Phase 2 starts.

---

## 7. SCHEMA PROTECTION

When creating or modifying views that feed the UI, the output columns must exactly match what the UI expects:

```sql
team_id, wins, losses, draws, matches_played, season
-- Use these EXACT names. Not "live_wins", not "total_matches".
```

The UI code stays untouched. The data source swap must be invisible to the front end.

---

## 8. PRE-ACTION CHECKLIST

Before taking ANY action, answer these questions:

1. **Does this bypass V2 architecture?** â†’ STOP. Use the proper pipeline.
2. **Does this touch UI code (.tsx)?** â†’ STOP. Get explicit user approval first.
3. **Is this a hack or a proper solution?** â†’ If hack, STOP.
4. **Does this change the schema the UI expects?** â†’ STOP. Views must match existing column names.
5. **Have I verified this against CLAUDE.md principles?** â†’ Must be YES.
6. **Will this affect all 3 layers?** â†’ Verify propagation through each.
7. **Am I batching multiple changes?** â†’ STOP. One at a time.

---

## 9. COMMON MISTAKES AND THEIR PREVENTION

| Mistake | Consequence | Prevention |
|---------|-------------|------------|
| Fuzzy matching outside the pipeline | Creates duplicate teams | Use canonical registries |
| Writing directly to production tables | Bypasses all validation | Use staging tables |
| `?? 0` on scores | Scheduled matches become 0-0 results | Use `null` |
| Division regex that requires a dash | Misses "U12" style divisions | Use `/U-?\d/` |
| Batching multiple UI changes | Regressions impossible to isolate | One change at a time |
| Skipping documentation | Knowledge lost between sessions | Update docs every session |
| Row-by-row database processing | Hours instead of seconds | Use bulk SQL |
| Empty canonical registry | Entire V2 dedup system is broken | Run `populateCanonicalTeams.cjs` |
| Direct import from GotSport rankings | Creates orphan teams with no matches | Must flow through normalizers |
| Scraping recreational/community data | Dilutes rankings with non-competitive teams | intakeValidator rejects (Session 84) |

---

## 10. KEY SCRIPTS REFERENCE

| Script | Purpose | Layer |
|--------|---------|-------|
| `scripts/adapters/*.js` | Source-specific data scraping | L1 |
| `scripts/universal/coreScraper.js` | Universal scraper framework | L1 |
| `scripts/universal/intakeValidator.js` | **NEW (Session 79)** Pre-staging validation gate | L1â†’L2 |
| `scripts/universal/dataQualityEngine.js` | **THE ONLY** stagingâ†’production path | L2 |
| `scripts/universal/pipelineAuth.js` | **NEW (Session 79)** Write authorization helper | L2 |
| `scripts/universal/normalizers/*.js` | Data standardization | L2 |
| `scripts/daily/verifyDataIntegrity.js` | **NEW (Session 79)** Post-processing checks | L2 |
| `scripts/daily/refreshViews.js` | Materialized view refresh | L3 |
| `scripts/maintenance/mergeTeams.js` | Team deduplication | L2 |
| `scripts/maintenance/populateCanonicalTeams.cjs` | Seed canonical registry from teams_v2 | L2 |
| `scripts/maintenance/mergeOrphansByNormalizedName.cjs` | Merge orphan teams using normalizer logic | L2 |
| `scripts/maintenance/fixDataDisconnect.cjs` | Recalc stats + fix birth_year + merge dupes | L2 |
| `scripts/maintenance/auditDataLifecycle.js` | Full 3-layer lifecycle audit | All |

**Archived (Session 79):** `validationPipeline.js`, `batchProcessStaging.js`, `fastBulkProcess.js`

---

## 13. WRITE PROTECTION (Session 79)

Database triggers block direct writes to `teams_v2` and `matches_v2` unless authorized.

### Authorizing Writes

```javascript
import { authorizePipelineWrite } from '../universal/pipelineAuth.js';

const client = await pool.connect();
try {
  // Call BEFORE any writes to teams_v2 or matches_v2
  await authorizePipelineWrite(client);

  // Now writes will succeed
  await client.query('INSERT INTO teams_v2 ...');
} finally {
  client.release();
}
```

### Emergency Override

If triggers are blocking legitimate operations:

```sql
-- Disable protection globally (EMERGENCY ONLY)
SELECT disable_write_protection();

-- Re-enable when done
SELECT enable_write_protection();
```

### Which Scripts Need Authorization

Any script that writes to `teams_v2` or `matches_v2`:
- âœ… `dataQualityEngine.js` - Authorized
- âœ… `recalculate_elo_v2.js` - Authorized
- âœ… `mergeTeams.js` - Authorized
- âœ… `mergeEvents.js` - Authorized
- âœ… `inferEventLinkage.js` - Authorized
- âœ… Deduplication scripts - Authorized

Scripts that only READ or write to OTHER tables (staging, canonical) don't need authorization.

### CommonJS (.cjs) Scripts

CommonJS scripts cannot import ES modules. Use the CJS wrapper:

```javascript
require('dotenv').config();
const { Pool } = require('pg');
const { authorizePipelineWrite } = require('../universal/pipelineAuthCJS.cjs');

const pool = new Pool({ connectionString: process.env.DATABASE_URL });

async function main() {
  // V2 ARCHITECTURE ENFORCEMENT: Authorize pipeline writes
  if (!DRY_RUN) {
    console.log('ðŸ” Authorizing pipeline writes...');
    await authorizePipelineWrite(pool);
    console.log('âœ… Pipeline write authorization granted\n');
  }

  // Now writes will succeed
  await pool.query('UPDATE teams_v2 SET ...');
}
```

### Authorized Scripts Manifest

See `scripts/manifests/authorized_writers.json` for the complete list of scripts and their authorization status.

### Script Categories

| Category | Authorization Required | Example |
|----------|----------------------|---------|
| Core Pipeline | âœ… Yes | dataQualityEngine.js |
| Maintenance | âœ… Yes | mergeTeams.js, fixDataDisconnect.cjs |
| Scrapers | âŒ No (writes to staging) | coreScraper.js |
| Debug | âš ï¸ Review before use | scripts/_debug/*.cjs |

---

## 14. ADAPTIVE LEARNING (Session 79)

The system learns from data to improve over time.

### Pattern Types

| Type | Purpose | Used By |
|------|---------|---------|
| `team_club_prefix` | Club name prefixes | teamNormalizer.js |
| `event_league_keywords` | League identification | eventNormalizer.js |
| `event_tournament_keywords` | Tournament identification | eventNormalizer.js |
| `canonical_match` | Team name matches | dataQualityEngine.js |

### Bootstrap Patterns

If `learned_patterns` table is empty:

```bash
node scripts/universal/adaptiveLearning.js --learn-teams --source all
node scripts/universal/adaptiveLearning.js --learn-events --source all
```

### Verify Adaptive Learning

Run verification to check health:

```bash
node scripts/daily/verifyAdaptiveLearning.js
```

### Key Metrics

| Metric | Target |
|--------|--------|
| Total patterns | > 100 |
| Team patterns | > 50 |
| Failure rate | < 30% |
| Usage rate | Growing over time |

---

## 11. DOCUMENTATION REQUIREMENTS

After any significant change:

1. Update **CLAUDE.md** with the new principle or lesson learned.
2. Update **docs/1-SESSION_HISTORY.md** with a session summary.
3. Update the **Master Project Scope** with progress.
4. If a new anti-pattern was discovered, add it to **this file** (GUARDRAILS.md) and to **docs/2-UNIVERSAL_DATA_QUALITY_SPEC.md**.

---

## 12. SESSION CHECKLISTS

### Start of Session
```
â–¡ Read GUARDRAILS.md (this file) in full
â–¡ Read CLAUDE.md principles section
â–¡ Check Master Project Scope for current state and immediate next step
â–¡ Ask user for current file versions before rewriting anything
â–¡ Identify which layers the current task affects
â–¡ Plan verification steps for each affected layer
```

### End of Session
```
â–¡ All changes tested?
â–¡ Documentation updated?
â–¡ No UI regressions introduced?
â–¡ Lifecycle audit passed?
â–¡ Master Project Scope updated with progress?
â–¡ CRITICAL_RULES SYNC: If new principles added, update .claude/hooks/CRITICAL_RULES.md
â–¡ GIT COMMIT: All changes committed and pushed?
â–¡ GIT STATUS: Working directory clean (except .env)?
```

---

## 15. GIT HYGIENE PROTOCOL (Session 80)

**Claude MUST proactively manage git commits.** Do not wait for user to ask.

### Commit Triggers (MANDATORY)

| Trigger | Action |
|---------|--------|
| End of every session | Commit all work before session ends |
| After completing a task | Each discrete task gets its own commit |
| Before switching context | Commit current work before starting new task |
| 10+ uncommitted files | Warn user, offer to commit immediately |

### Commit Checklist
```
â–¡ Run `git status` to see uncommitted changes
â–¡ Stage relevant files (NOT .env)
â–¡ Write descriptive commit message
â–¡ Push to remote
â–¡ Verify push succeeded
```

### Anti-patterns
- âŒ Ending session with uncommitted changes
- âŒ Accumulating 10+ files without committing
- âŒ Waiting for user to ask "did you commit?"
- âŒ Committing .env or secrets

### Proactive Behavior

Claude should:
1. **Start of session:** Run `git status` to catch uncommitted work from previous sessions
2. **After each task:** Ask "Should I commit these changes now?"
3. **10+ files uncommitted:** Warn user immediately
4. **End of session:** ALWAYS ensure all changes are committed and pushed

### Why This Matters

Session 80 discovered 280+ files accumulated over 30 sessions without being committed. This created:
- Risk of lost work if machine fails
- Mismatch between local code and git history
- No backup of weeks of development

**Prevention:** Commit early, commit often. Every task = one commit.

---

## 16. FOUNDATION FIRST PRINCIPLE (Session 83)

**ALL historical data must be extracted and cleaned BEFORE relying on daily scrape.**

### The Principle

```
ALL Historical Data â†’ Clean via V2 Pipeline â†’ Best Possible Foundation
                                                      â†“
                                            Daily Scrape Adds NEW Data
```

### Key Rules

1. **Complete Extraction:** Get ALL raw data from ALL sources before daily scrape
2. **Discrepancy Check:** Never assume "more records = complete"
3. **Fill Gaps First:** Identify and fill V1â†’V2 gaps
4. **Foundation Quality:** Daily scrape BUILDS ON the foundation

### Anti-patterns

- âŒ Assuming V2 is complete because it has "more records"
- âŒ Comparing only total counts, not same-date/same-team matches
- âŒ Skipping V1 migration because V2 "looks bigger"
- âŒ Starting daily scrape before foundation is solid

### Verification

Before declaring data foundation complete:

```sql
-- Check for V1 entries missing from V2 (same dates)
SELECT COUNT(*)
FROM v1_table rh1
WHERE NOT EXISTS (
  SELECT 1 FROM v2_table rh2
  WHERE rh2.team_id = rh1.team_id
    AND rh2.snapshot_date = rh1.snapshot_date
);
-- Should be 0 or close to 0
```

### Session 83 Lesson

V1 rank_history had 49,729 entries MISSING from V2 for the same dates, even though V2 had more total records. **Volume â‰  completeness.**

---

**The golden rule: Data Integrity MAX. One team, one truth, everywhere in the app.**

---

## 17. UNIVERSAL CANONICAL RESOLVER (Session 87)

**Every entity MUST resolve to exactly ONE SoccerView ID through the same 6-step algorithm.**

### The Resolution Algorithm

```
1. EXACT ID MATCH      â†’ Check if ID already exists
2. SEMANTIC KEY MATCH  â†’ Check by unique semantic attributes
3. CANONICAL REGISTRY  â†’ Check aliases in canonical_* tables
4. FUZZY MATCH         â†’ pg_trgm similarity with thresholds
5. CREATE NEW          â†’ Only if all above fail
6. SELF-LEARNING       â†’ Update registries after any action
```

### CRITICAL: Fuzzy Matching Constraints

**Fuzzy matching REQUIRES exact match on constraining fields.** This prevents cross-entity merges.

| Entity | Fuzzy Field | Exact Match Fields |
|--------|-------------|-------------------|
| Team | `canonical_name` | `birth_year` AND `gender` |
| League | `name` | `year` AND `state` |
| Tournament | `name` | `start_date` AND `state` |
| Club | `name` | `state` |

**Example - Why this matters:**
```javascript
// âŒ WRONG - Groups by name + birth_year, ignores gender
GROUP BY canonical_name, birth_year
// This merges "Jackson SC 2015 Girls Gold" with "Jackson SC 2015 Boys Team 1"

// âœ… CORRECT - Groups by all constraining fields
GROUP BY canonical_name, birth_year, gender
// These are DIFFERENT teams in DIFFERENT age groups
```

### Fuzzy Thresholds

| Similarity | Action |
|------------|--------|
| >= 0.95 | Auto-merge (with audit log) |
| 0.85 - 0.94 | Flag for human review |
| < 0.85 | Not a match - create new |

### Semantic Keys by Entity

| Entity | Semantic Key (uniqueness constraint) |
|--------|-------------------------------------|
| Team | `(display_name, birth_year, gender)` |
| Match | `(match_date, home_team_id, away_team_id)` |
| League | `(source_event_id, source_platform)` |
| Tournament | `(source_event_id, source_platform)` |
| Club | `(name, state)` |

### Using the Resolver

```javascript
import { resolveEntity, resolveTeam } from '../universal/canonicalResolver.js';

// Resolve a team
const result = await resolveEntity(client, 'team', {
  display_name: 'Sporting BV Pre-NAL 15',
  canonical_name: 'sporting bv pre-nal 15',
  birth_year: 2015,
  gender: 'Boys',
  state: 'KS'
});

// result: { action: 'found'|'merged'|'review'|'created', id: uuid }
```

### Anti-patterns

- âŒ Fuzzy matching that ignores `birth_year` or `gender`
- âŒ Grouping teams by name only (missing constraining fields)
- âŒ Auto-merging without audit trail
- âŒ Skipping canonical registry lookup
- âŒ Creating entities without self-learning step

### Key Files

| File | Purpose |
|------|---------|
| `scripts/universal/canonicalResolver.js` | Universal resolution functions |
| `scripts/universal/deduplication/teamDedup.js` | Team deduplication (fixed Session 87) |
| `scripts/universal/deduplication/matchDedup.js` | Match deduplication (soft-delete, Session 86) |
| `scripts/universal/deduplication/eventDedup.js` | Event deduplication |
| `scripts/maintenance/fastProcessStaging.cjs` | Universal bulk staging processor (Session 87.2) |

---
