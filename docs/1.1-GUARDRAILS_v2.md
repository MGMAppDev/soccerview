# SOCCERVIEW GUARDRAILS

> **‚ö†Ô∏è MANDATORY READING ‚Äî DO NOT SKIP**
>
> **What this document is:** A permanent engineering rulebook for the SoccerView project. Every rule here was learned the hard way and exists to prevent catastrophic mistakes. These are non-negotiable constraints.
>
> **How Claude Code must treat this document:**
> 1. Read this file IN FULL before taking ANY action in a session.
> 2. Treat every rule as an absolute constraint ‚Äî not a suggestion.
> 3. If a proposed action conflicts with any rule below, STOP and discuss with the user before proceeding.
> 4. This document is append-only. Rules may be ADDED but never removed or weakened.
> 5. Do not reference this document's existence or quote it back to the user. Just follow it silently.
> 6. Do not use this document to track session history, progress, or completed work. It is purely prescriptive.

---

## 1. UI PROTECTION

The UI represents 100+ hours of manual QA and polish. It is the most fragile and expensive part of the project.

- **NEVER** touch `.tsx` files without explicit user approval.
- **NEVER** batch multiple UI changes together. One change ‚Üí verify ‚Üí next change.
- **NEVER** change component structure, styling, spacing, or layouts.
- If the UI shows wrong data, fix the **data source** ‚Äî not the UI.
- Data layer fixes only. The UI must receive the **exact same schema** it already expects.
- Test one page at a time. Verify it works before touching the next.

---

## 2. V2 ARCHITECTURE

All data must flow through the established pipeline. No shortcuts.

```
Staging Tables ‚Üí dataQualityEngine ‚Üí Normalizers ‚Üí Canonical Registries ‚Üí Production Tables
```

- **NEVER** bypass normalizers with ad-hoc fuzzy matching scripts.
- **NEVER** write directly to `teams_v2` or `matches_v2`. Use staging tables first.
- **NEVER** use deprecated legacy scripts without checking if a V2 replacement exists.
- **NEVER** use the Supabase client for bulk operations. Use `pg Pool` with direct SQL.
- **NEVER** process records row-by-row. Use bulk SQL (`CASE`, `unnest`, `INSERT...SELECT`).
- Always use `canonical_teams`, `canonical_events`, `canonical_clubs` for deduplication.
- Always use `teamNormalizer.js`, `eventNormalizer.js`, `matchNormalizer.js` for standardization.
- **NEVER** create tournaments or leagues with generic names ("Event 12093", "GotSport", bare numbers). Use `isGeneric()` from `resolveEventName.cjs` to validate. Return NULL and skip event creation instead (Session 91).
- Speed benchmark: 1,000+ records/second is the minimum expectation. If slower, refactor.

### Canonical Registry Health

Before any deduplication work, verify coverage:

```sql
SELECT COUNT(*) FROM teams_v2;
SELECT COUNT(*) FROM canonical_teams;
-- canonical_teams should be ~90%+ of teams_v2
```

If `canonical_teams` is below 50% of `teams_v2`, the V2 deduplication architecture **cannot function**. Run `populateCanonicalTeams.cjs --execute` before proceeding.

---

## 3. DATA INTEGRITY

Data integrity is the #1 priority across all decisions. One team, one truth, everywhere in the app.

- **NEVER** use `?? 0` or `|| 0` for scores. This destroys NULL values that represent scheduled/future matches.
- **NEVER** use `COALESCE(score, 0)` in SQL views.
- **NEVER** mark events as processed if `matches.length === 0`.
- **NEVER** assume team names are consistent across events. The same team may appear under different names.
- **NEVER** use `source_match_key` for match uniqueness. Use semantic key: `(match_date, home_team_id, away_team_id)`.
- Always preserve `NULL` scores for scheduled/future matches.
- Checkpoint logic: only mark an event processed **inside** a block that confirmed matches were found.
- Run team deduplication after any multi-source data import.

### Match Uniqueness (Session 85)

Matches are uniquely identified by **semantic key** using SoccerView Team IDs:

```sql
-- UNIQUE constraint on matches_v2
UNIQUE (match_date, home_team_id, away_team_id)
```

**Why NOT source_match_key?**
- Same match can come from multiple sources with different source keys
- V1 migration created duplicates because V1 had different keys than V2 scrapers
- Semantic key = same teams, same date = same match (regardless of source)

**Pipeline ON CONFLICT pattern:**
```sql
INSERT INTO matches_v2 (...)
ON CONFLICT (match_date, home_team_id, away_team_id) DO UPDATE SET
  home_score = CASE WHEN matches_v2.home_score IS NOT NULL THEN matches_v2.home_score ELSE EXCLUDED.home_score END,
  -- Keep existing scores, fill in missing ones
```

**source_match_key purpose:** Audit trail only. Tracks which source provided the data.

### Match Deletion - ALWAYS Soft Delete (Session 86)

**CRITICAL:** Match deduplication MUST use soft delete, not hard delete.

```sql
-- ‚ùå WRONG ‚Äî Data is lost permanently
DELETE FROM matches_v2 WHERE id = ANY($1);

-- ‚úÖ CORRECT ‚Äî Data is preserved for recovery
UPDATE matches_v2
SET deleted_at = NOW(),
    deletion_reason = 'Semantic duplicate of ' || $2
WHERE id = ANY($1);
```

**Why this matters:**
- Session 85 hard-deleted 9,160 matches, causing ALL match history to disappear
- "Duplicate" matches are often the SAME real-world match from different sources
- Soft delete preserves data for recovery while excluding from active queries
- Always include `WHERE deleted_at IS NULL` in active match queries

**Recovery:** Soft-deleted data can be recovered by setting `deleted_at = NULL`.

---

## 4. UNIVERSAL CODE PATTERNS

### Division Detection
```javascript
// ‚úÖ CORRECT ‚Äî dash is optional
/U-?\d{1,2}\b|20[01]\d/i

// ‚ùå WRONG ‚Äî requires dash, misses "U12"
/U-\d+/
```

### Age Group Extraction
```javascript
// ‚úÖ CORRECT ‚Äî handles "U12", "U-12", "U 12"
/\bU[-\s]?(\d{1,2})\b/i

// ‚ùå WRONG ‚Äî only matches "U12"
/u(\d{1,2})/
```

### NULL Score Preservation
```javascript
// ‚úÖ CORRECT ‚Äî preserves scheduled matches
home_score: hasValidScores ? homeScore : null

// ‚ùå WRONG ‚Äî turns scheduled matches into 0-0 results
home_score: homeScore ?? 0
```

### Duplicate Club Prefix Detection
```sql
-- GotSport rankings sometimes produce "One FC One FC B2015 PRE-MLS"
-- Detect with:
WHERE split_part(canonical_name, ' ', 1) = split_part(canonical_name, ' ', 2)
   OR (split_part(canonical_name, ' ', 1) = split_part(canonical_name, ' ', 3)
       AND split_part(canonical_name, ' ', 2) = split_part(canonical_name, ' ', 4))
```

### Bulk Operations
```javascript
// ‚ùå WRONG ‚Äî takes hours for 100K+ records
for (const team of teams) {
  await supabase.from('teams_v2').update({ elo: newElo }).eq('id', team.id);
}

// ‚úÖ CORRECT ‚Äî takes seconds for 100K+ records
const pool = new Pool({ connectionString: process.env.DATABASE_URL });
await pool.query(`
  WITH merge_data AS (
    SELECT unnest($1::uuid[]) as id, unnest($2::int[]) as elo
  )
  UPDATE teams_v2 t SET elo_rating = md.elo
  FROM merge_data md WHERE t.id = md.id
`, [ids, elos]);
```

---

## 5. THREE-LAYER LIFECYCLE

Every fix must be verified across all three layers before it can be considered complete.

```
Layer 1 (Intake)        ‚Üí Layer 2 (Processing)       ‚Üí Layer 3 (Presentation)
Scrapers / Adapters     ‚Üí Validation / Normalizers    ‚Üí Views / App UI
```

Before closing ANY fix, ask: **Did this change propagate correctly through all three layers?**

Run the lifecycle audit to verify: `node scripts/maintenance/auditDataLifecycle.js`

---

## 6. TWO-PHASE DATA COLLECTION

| Phase | Script | Purpose | Writes To |
|-------|--------|---------|-----------|
| **1. Team Scraper** | `runTeamScraperBatch.js` | Discover event IDs | `event_registry` |
| **2. Event Scraper** | `runEventScraperBatch.js` | Get actual match scores | `match_results` |

Phase 1 must complete before Phase 2 starts.

---

## 7. SCHEMA PROTECTION

When creating or modifying views that feed the UI, the output columns must exactly match what the UI expects:

```sql
team_id, wins, losses, draws, matches_played, season
-- Use these EXACT names. Not "live_wins", not "total_matches".
```

The UI code stays untouched. The data source swap must be invisible to the front end.

---

## 8. PRE-ACTION CHECKLIST

Before taking ANY action, answer these questions:

1. **Does this bypass V2 architecture?** ‚Üí STOP. Use the proper pipeline.
2. **Does this touch UI code (.tsx)?** ‚Üí STOP. Get explicit user approval first.
3. **Is this a hack or a proper solution?** ‚Üí If hack, STOP.
4. **Does this change the schema the UI expects?** ‚Üí STOP. Views must match existing column names.
5. **Have I verified this against CLAUDE.md principles?** ‚Üí Must be YES.
6. **Will this affect all 3 layers?** ‚Üí Verify propagation through each.
7. **Am I batching multiple changes?** ‚Üí STOP. One at a time.

---

## 9. COMMON MISTAKES AND THEIR PREVENTION

| Mistake | Consequence | Prevention |
|---------|-------------|------------|
| Fuzzy matching outside the pipeline | Creates duplicate teams | Use canonical registries |
| Writing directly to production tables | Bypasses all validation | Use staging tables |
| `?? 0` on scores | Scheduled matches become 0-0 results | Use `null` |
| Division regex that requires a dash | Misses "U12" style divisions | Use `/U-?\d/` |
| Batching multiple UI changes | Regressions impossible to isolate | One change at a time |
| Skipping documentation | Knowledge lost between sessions | Update docs every session |
| Row-by-row database processing | Hours instead of seconds | Use bulk SQL |
| Empty canonical registry | Entire V2 dedup system is broken | Run `populateCanonicalTeams.cjs` |
| Direct import from GotSport rankings | Creates orphan teams with no matches | Must flow through normalizers |
| Scraping recreational/community data | Dilutes rankings with non-competitive teams | intakeValidator rejects (Session 84) |

---

## 10. KEY SCRIPTS REFERENCE

| Script | Purpose | Layer |
|--------|---------|-------|
| `scripts/adapters/*.js` | Source-specific data scraping | L1 |
| `scripts/universal/coreScraper.js` | Universal scraper framework | L1 |
| `scripts/universal/intakeValidator.js` | **NEW (Session 79)** Pre-staging validation gate | L1‚ÜíL2 |
| `scripts/universal/dataQualityEngine.js` | **THE ONLY** staging‚Üíproduction path | L2 |
| `scripts/universal/pipelineAuth.js` | **NEW (Session 79)** Write authorization helper | L2 |
| `scripts/universal/normalizers/*.js` | Data standardization | L2 |
| `scripts/daily/verifyDataIntegrity.js` | **NEW (Session 79)** Post-processing checks | L2 |
| `scripts/daily/refreshViews.js` | Materialized view refresh | L3 |
| `scripts/maintenance/mergeTeams.js` | Team deduplication | L2 |
| `scripts/maintenance/populateCanonicalTeams.cjs` | Seed canonical registry from teams_v2 | L2 |
| `scripts/maintenance/mergeOrphansByNormalizedName.cjs` | Merge orphan teams using normalizer logic | L2 |
| `scripts/maintenance/fixDataDisconnect.cjs` | Recalc stats + fix birth_year + merge dupes | L2 |
| `scripts/maintenance/auditDataLifecycle.js` | Full 3-layer lifecycle audit | All |

**Archived (Session 79):** `validationPipeline.js`, `batchProcessStaging.js`, `fastBulkProcess.js`

---

## 13. WRITE PROTECTION (Session 79)

Database triggers block direct writes to `teams_v2` and `matches_v2` unless authorized.

### Authorizing Writes

```javascript
import { authorizePipelineWrite } from '../universal/pipelineAuth.js';

const client = await pool.connect();
try {
  // Call BEFORE any writes to teams_v2 or matches_v2
  await authorizePipelineWrite(client);

  // Now writes will succeed
  await client.query('INSERT INTO teams_v2 ...');
} finally {
  client.release();
}
```

### Emergency Override

If triggers are blocking legitimate operations:

```sql
-- Disable protection globally (EMERGENCY ONLY)
SELECT disable_write_protection();

-- Re-enable when done
SELECT enable_write_protection();
```

### Which Scripts Need Authorization

Any script that writes to `teams_v2` or `matches_v2`:
- ‚úÖ `dataQualityEngine.js` - Authorized
- ‚úÖ `recalculate_elo_v2.js` - Authorized
- ‚úÖ `mergeTeams.js` - Authorized
- ‚úÖ `mergeEvents.js` - Authorized
- ‚úÖ `inferEventLinkage.js` - Authorized
- ‚úÖ Deduplication scripts - Authorized

Scripts that only READ or write to OTHER tables (staging, canonical) don't need authorization.

### CommonJS (.cjs) Scripts

CommonJS scripts cannot import ES modules. Use the CJS wrapper:

```javascript
require('dotenv').config();
const { Pool } = require('pg');
const { authorizePipelineWrite } = require('../universal/pipelineAuthCJS.cjs');

const pool = new Pool({ connectionString: process.env.DATABASE_URL });

async function main() {
  // V2 ARCHITECTURE ENFORCEMENT: Authorize pipeline writes
  if (!DRY_RUN) {
    console.log('üîê Authorizing pipeline writes...');
    await authorizePipelineWrite(pool);
    console.log('‚úÖ Pipeline write authorization granted\n');
  }

  // Now writes will succeed
  await pool.query('UPDATE teams_v2 SET ...');
}
```

### Authorized Scripts Manifest

See `scripts/manifests/authorized_writers.json` for the complete list of scripts and their authorization status.

### Script Categories

| Category | Authorization Required | Example |
|----------|----------------------|---------|
| Core Pipeline | ‚úÖ Yes | dataQualityEngine.js |
| Maintenance | ‚úÖ Yes | mergeTeams.js, fixDataDisconnect.cjs |
| Scrapers | ‚ùå No (writes to staging) | coreScraper.js |
| Debug | ‚ö†Ô∏è Review before use | scripts/_debug/*.cjs |

---

## 14. ADAPTIVE LEARNING (Session 79)

The system learns from data to improve over time.

### Pattern Types

| Type | Purpose | Used By |
|------|---------|---------|
| `team_club_prefix` | Club name prefixes | teamNormalizer.js |
| `event_league_keywords` | League identification | eventNormalizer.js |
| `event_tournament_keywords` | Tournament identification | eventNormalizer.js |
| `canonical_match` | Team name matches | dataQualityEngine.js |

### Bootstrap Patterns

If `learned_patterns` table is empty:

```bash
node scripts/universal/adaptiveLearning.js --learn-teams --source all
node scripts/universal/adaptiveLearning.js --learn-events --source all
```

### Verify Adaptive Learning

Run verification to check health:

```bash
node scripts/daily/verifyAdaptiveLearning.js
```

### Key Metrics

| Metric | Target |
|--------|--------|
| Total patterns | > 100 |
| Team patterns | > 50 |
| Failure rate | < 30% |
| Usage rate | Growing over time |

---

## 11. DOCUMENTATION REQUIREMENTS

After any significant change:

1. Update **CLAUDE.md** with the new principle or lesson learned.
2. Update **docs/1-SESSION_HISTORY.md** with a session summary.
3. Update the **Master Project Scope** with progress.
4. If a new anti-pattern was discovered, add it to **this file** (GUARDRAILS.md) and to **docs/2-UNIVERSAL_DATA_QUALITY_SPEC.md**.

---

## 12. SESSION CHECKLISTS

### Start of Session
```
‚ñ° Read GUARDRAILS.md (this file) in full
‚ñ° Read CLAUDE.md principles section
‚ñ° Check Master Project Scope for current state and immediate next step
‚ñ° Ask user for current file versions before rewriting anything
‚ñ° Identify which layers the current task affects
‚ñ° Plan verification steps for each affected layer
```

### End of Session
```
‚ñ° All changes tested?
‚ñ° Documentation updated?
‚ñ° No UI regressions introduced?
‚ñ° Lifecycle audit passed?
‚ñ° Master Project Scope updated with progress?
‚ñ° CRITICAL_RULES SYNC: If new principles added, update .claude/hooks/CRITICAL_RULES.md
‚ñ° GIT COMMIT: All changes committed and pushed?
‚ñ° GIT STATUS: Working directory clean (except .env)?
```

---

## 15. GIT HYGIENE PROTOCOL (Session 80)

**Claude MUST proactively manage git commits.** Do not wait for user to ask.

### Commit Triggers (MANDATORY)

| Trigger | Action |
|---------|--------|
| End of every session | Commit all work before session ends |
| After completing a task | Each discrete task gets its own commit |
| Before switching context | Commit current work before starting new task |
| 10+ uncommitted files | Warn user, offer to commit immediately |

### Commit Checklist
```
‚ñ° Run `git status` to see uncommitted changes
‚ñ° Stage relevant files (NOT .env)
‚ñ° Write descriptive commit message
‚ñ° Push to remote
‚ñ° Verify push succeeded
```

### Anti-patterns
- ‚ùå Ending session with uncommitted changes
- ‚ùå Accumulating 10+ files without committing
- ‚ùå Waiting for user to ask "did you commit?"
- ‚ùå Committing .env or secrets

### Proactive Behavior

Claude should:
1. **Start of session:** Run `git status` to catch uncommitted work from previous sessions
2. **After each task:** Ask "Should I commit these changes now?"
3. **10+ files uncommitted:** Warn user immediately
4. **End of session:** ALWAYS ensure all changes are committed and pushed

### Why This Matters

Session 80 discovered 280+ files accumulated over 30 sessions without being committed. This created:
- Risk of lost work if machine fails
- Mismatch between local code and git history
- No backup of weeks of development

**Prevention:** Commit early, commit often. Every task = one commit.

---

## 16. FOUNDATION FIRST PRINCIPLE (Session 83)

**ALL historical data must be extracted and cleaned BEFORE relying on daily scrape.**

### The Principle

```
ALL Historical Data ‚Üí Clean via V2 Pipeline ‚Üí Best Possible Foundation
                                                      ‚Üì
                                            Daily Scrape Adds NEW Data
```

### Key Rules

1. **Complete Extraction:** Get ALL raw data from ALL sources before daily scrape
2. **Discrepancy Check:** Never assume "more records = complete"
3. **Fill Gaps First:** Identify and fill V1‚ÜíV2 gaps
4. **Foundation Quality:** Daily scrape BUILDS ON the foundation

### Anti-patterns

- ‚ùå Assuming V2 is complete because it has "more records"
- ‚ùå Comparing only total counts, not same-date/same-team matches
- ‚ùå Skipping V1 migration because V2 "looks bigger"
- ‚ùå Starting daily scrape before foundation is solid

### Verification

Before declaring data foundation complete:

```sql
-- Check for V1 entries missing from V2 (same dates)
SELECT COUNT(*)
FROM v1_table rh1
WHERE NOT EXISTS (
  SELECT 1 FROM v2_table rh2
  WHERE rh2.team_id = rh1.team_id
    AND rh2.snapshot_date = rh1.snapshot_date
);
-- Should be 0 or close to 0
```

### Session 83 Lesson

V1 rank_history had 49,729 entries MISSING from V2 for the same dates, even though V2 had more total records. **Volume ‚â† completeness.**

---

**The golden rule: Data Integrity MAX. One team, one truth, everywhere in the app.**

---

## 17. UNIVERSAL CANONICAL RESOLVER (Session 87)

**Every entity MUST resolve to exactly ONE SoccerView ID through the same 6-step algorithm.**

### The Resolution Algorithm

```
1. EXACT ID MATCH      ‚Üí Check if ID already exists
2. SEMANTIC KEY MATCH  ‚Üí Check by unique semantic attributes
3. CANONICAL REGISTRY  ‚Üí Check aliases in canonical_* tables
4. FUZZY MATCH         ‚Üí pg_trgm similarity with thresholds
5. CREATE NEW          ‚Üí Only if all above fail
6. SELF-LEARNING       ‚Üí Update registries after any action
```

### CRITICAL: Fuzzy Matching Constraints

**Fuzzy matching REQUIRES exact match on constraining fields.** This prevents cross-entity merges.

| Entity | Fuzzy Field | Exact Match Fields |
|--------|-------------|-------------------|
| Team | `canonical_name` | `birth_year` AND `gender` |
| League | `name` | `year` AND `state` |
| Tournament | `name` | `start_date` AND `state` |
| Club | `name` | `state` |

**Example - Why this matters:**
```javascript
// ‚ùå WRONG - Groups by name + birth_year, ignores gender
GROUP BY canonical_name, birth_year
// This merges "Jackson SC 2015 Girls Gold" with "Jackson SC 2015 Boys Team 1"

// ‚úÖ CORRECT - Groups by all constraining fields
GROUP BY canonical_name, birth_year, gender
// These are DIFFERENT teams in DIFFERENT age groups
```

### Fuzzy Thresholds

| Similarity | Action |
|------------|--------|
| >= 0.95 | Auto-merge (with audit log) |
| 0.85 - 0.94 | Flag for human review |
| < 0.85 | Not a match - create new |

### Semantic Keys by Entity

| Entity | Semantic Key (uniqueness constraint) |
|--------|-------------------------------------|
| Team | `(display_name, birth_year, gender)` |
| Match | `(match_date, home_team_id, away_team_id)` |
| League | `(source_event_id, source_platform)` |
| Tournament | `(source_event_id, source_platform)` |
| Club | `(name, state)` |

### Using the Resolver

```javascript
import { resolveEntity, resolveTeam } from '../universal/canonicalResolver.js';

// Resolve a team
const result = await resolveEntity(client, 'team', {
  display_name: 'Sporting BV Pre-NAL 15',
  canonical_name: 'sporting bv pre-nal 15',
  birth_year: 2015,
  gender: 'Boys',
  state: 'KS'
});

// result: { action: 'found'|'merged'|'review'|'created', id: uuid }
```

### Anti-patterns

- ‚ùå Fuzzy matching that ignores `birth_year` or `gender`
- ‚ùå Grouping teams by name only (missing constraining fields)
- ‚ùå Auto-merging without audit trail
- ‚ùå Skipping canonical registry lookup
- ‚ùå Creating entities without self-learning step

### Key Files

| File | Purpose |
|------|---------|
| `scripts/universal/canonicalResolver.js` | Universal resolution functions |
| `scripts/universal/deduplication/teamDedup.js` | Team deduplication (fixed Session 87) |
| `scripts/universal/deduplication/matchDedup.js` | Match deduplication (soft-delete, Session 86) |
| `scripts/universal/deduplication/eventDedup.js` | Event deduplication |
| `scripts/maintenance/fastProcessStaging.cjs` | Universal bulk staging processor (Session 87.2) |

---

## 19. SEASON COMPLETENESS ‚Äî WE ARE ALWAYS IN-SEASON (Session 99/112)

> **üö® "BETWEEN SEASONS" IS BANNED AS AN EXCUSE. WE ARE ALWAYS IN THE ACTIVE SEASON.**
> **The 2025-26 season runs August 1, 2025 ‚Üí July 31, 2026. It is NEVER "between seasons" during this window.**
> **If a scrape returns 0 matches: INVESTIGATE. Find the correct event ID. DO NOT accept 0.**

**The SoccerView season runs August 1 ‚Üí July 31.** Both halves MUST be scraped:
- **Fall half (Aug-Dec 2025):** Peak league play ‚Äî if we missed it, backfill now
- **Spring half (Feb-Jun 2026):** Active right now ‚Äî scrape it
- **NEVER mark a state "done" because one half returned 0 matches.** Find the other half.

### Season Calendar

| Month | Season Phase | Scraping Action |
|-------|-------------|----------------|
| Aug-Nov | Fall season (PEAK league play) | Scrape Fall events IMMEDIATELY |
| Dec-Jan | Winter / indoor | Scrape winter leagues |
| Feb-Mar | Spring ‚Äî **WE ARE HERE** | Spring events are ACTIVE NOW ‚Äî scrape them |
| Apr-Jun | Spring season | Full coverage |
| Jul | Season end | Audit gaps, plan ahead |

### Critical Rules

1. **NEVER say "between seasons."** We are ALWAYS in the active 2025-26 season (Aug 2025-Jul 2026).
2. **0 matches = WRONG EVENT ID or SCRAPER BUG.** Not "between seasons." Fix it.
3. **`year` field = season END year** (2026 for the 2025-26 season), NOT calendar year.
4. **SportsAffinity uses DIFFERENT subdomains per season** (e.g., `gs-fall25{orgcode}`).
5. **GotSport uses SEPARATE event IDs** for Fall vs Spring ‚Äî find BOTH.
6. **Every state needs BOTH Fall + Spring event IDs** configured.
7. **Spring 2026 events start Feb-Mar 2026.** RIGHT NOW. Go get them.

### Pre-Scrape Checklist (MANDATORY)

Before scraping any state or source:

```
‚ñ° Do we have Fall 2025 (Aug-Dec) data for this state?
‚ñ° Do we have Spring 2026 (Feb-Jun) data for this state?
‚ñ° Are we using the correct event IDs for BOTH halves?
‚ñ° If a platform uses different subdomains per season, do we have ALL subdomains?
‚ñ° If 0 matches returned ‚Äî have we tried alternate event IDs? Have we checked the platform?
‚ñ° Are there any states marked "between seasons" that should be re-investigated NOW?
```

### Anti-patterns (BANNED ‚Äî ZERO TOLERANCE)

- ‚ùå Saying "between seasons" ‚Äî THE SEASON IS ACTIVE AUG 2025-JUL 2026
- ‚ùå Accepting 0 matches without finding the correct event ID
- ‚ùå Marking a state "done" with 0 matches from either half
- ‚ùå "Retry next season" ‚Äî the season is NOW, go find the data
- ‚ùå Configuring ONLY one half when the other half exists

### DATA RETENTION WARNING ‚Äî Some Platforms PURGE Data Between Seasons (Session 105)

**CRITICAL LESSON:** Not all platforms retain historical data. Some DELETE match data when the active season ends.

| Platform | Data Retention | Risk Level |
|----------|---------------|------------|
| GotSport | ‚úÖ Retains all seasons | LOW |
| SportsAffinity | ‚úÖ Retains via season subdomains | LOW |
| PlayMetrics | ‚úÖ Retains via season URLs | LOW |
| Demosphere | ‚úÖ Retains via season endpoints | LOW |
| SINC Sports | ‚úÖ Retains per-season data | LOW |
| Heartland CGI | ‚úÖ Retains dynamically | LOW |
| Squadi | ‚úÖ Retains via REST API | LOW |
| **RI Super Liga** | **‚ùå PURGES between seasons** | **CRITICAL** |
| TotalGlobalSports | ‚úÖ Retains per-event | LOW |
| MLS Next | ‚úÖ Retains per-season | LOW |

**RI Super Liga (thesuperliga.com) ‚Äî PERMANENT DATA LOSS:**
- Custom PHP site. Only shows current active season.
- Fall 2025 data existed Aug-Oct 2025 but was DELETED when season ended.
- Wayback Machine captured page structure but NOT POST response data.
- **UNRECOVERABLE.** Fall 2025 match data is permanently lost.
- **MUST scrape during active season:** Spring ~March 28 ‚Üí June, Fall ~Aug ‚Üí Oct.

**NEW RULE:** When building a new adapter, ALWAYS check:
1. Does the platform retain historical season data? (Test by requesting a past season)
2. If YES ‚Üí safe to build adapter any time, backfill later
3. If NO ‚Üí **MUST deploy adapter BEFORE the current season ends or data is lost forever**
4. For data-purging platforms, add a "SCRAPE DURING SEASON" warning in the state checklist

### Root Cause (Session 99 + Session 105)

Session 99: The season was documented as a DATA PROPERTY (ELO uses Aug 1 start date) but not as an OPERATIONAL REQUIREMENT (scrapers must cover both halves). This led to an entire session configuring only Spring 2026 events while Fall 2025 was completely ignored.

Session 105: RI Super Liga adapter was planned for Session 105 but the platform had already purged Fall 2025 data. The adapter should have been built DURING Fall 2025 (Aug-Oct) or the data retention behavior should have been discovered and flagged during platform research (Session 98b).

---

## 18. NEVER ACCEPT "BLOCKED" ‚Äî FIND THE BACK DOOR (Session 99)

**ABSOLUTE RULE: When a data source appears blocked, inaccessible, or difficult to scrape ‚Äî you MUST find a way around it. No excuses. No deferring. No "we'll come back to it later."**

### The Mandate

SoccerView's promise is COMPLETE national coverage. Every premier league, every state, every division. A parent searching for their kid's team MUST find it. If data exists on any public website, WE MUST GET IT INTO SOCCERVIEW.

### What "Never Accept Blocked" Means

| Situation | WRONG Response | RIGHT Response |
|-----------|---------------|----------------|
| Website returns 403 | "Site blocks scrapers" | Try different User-Agent, stealth Puppeteer, mobile endpoints |
| SPA with no static HTML | "Can't parse with Cheerio" | Use Puppeteer, intercept XHR/fetch, find the underlying API |
| Login required | "Need authentication" | Check for public guest URLs, embed links, widget endpoints, API keys in page source |
| Rate limited | "Too slow to scrape" | Add delays, use p-limit concurrency, cache responses, scrape incrementally |
| Data in PDF/images | "Can't parse this format" | Use PDF parsing libraries, OCR if needed |
| "Between seasons" | "No data available" | Scrape historical seasons, check Spring/Fall variants, try prior year event IDs |
| Complex JS rendering | "Page doesn't load" | Wait for network idle, intercept API calls, check for embedded JSON |
| Different data format | "Doesn't match our schema" | Write an adapter ‚Äî that's literally what adapters are for |

### Techniques to Deploy (minimum 5 before deferring)

1. **Inspect Network tab** ‚Äî Most SPAs fetch data via XHR/fetch. Find the API endpoint directly.
2. **Check page source** ‚Äî Many sites embed JSON in `<script>` tags or `window.__INITIAL_STATE__`.
3. **Try `/api/`, `/json/`, `/data/` endpoints** ‚Äî Many platforms have undocumented public APIs.
4. **Use Puppeteer stealth** ‚Äî `puppeteer-extra-plugin-stealth` bypasses most bot detection.
5. **Check mobile endpoints** ‚Äî Mobile apps often hit simpler, less-protected APIs.
6. **Vary User-Agent strings** ‚Äî Try Googlebot, mobile browsers, curl patterns.
7. **Look for embed/widget URLs** ‚Äî Many platforms have embeddable widgets with public access.
8. **Check Wayback Machine** ‚Äî Historical data may still be accessible.
9. **Search for alternative data sources** ‚Äî Same league data may exist on a different platform.
10. **Use WebSearch to research** ‚Äî Other developers may have documented the API in forums/GitHub.

### When "Between Seasons" ‚Äî NEVER Mark as Done

"Between seasons" = TRY AGAIN LATER, not "skip permanently." Track with:
- Exact retry date (when next season starts)
- Alternative season IDs to try
- Prior year event IDs that may have data

### Accountability

Before marking ANY data source as "not accessible" or deferring:
1. Document EVERY technique tried (minimum 5 approaches)
2. Explain specifically why each failed
3. Propose what to try next session
4. Get USER APPROVAL before deferring

**If you haven't tried at least 5 different approaches, you haven't tried hard enough.**

### Anti-patterns (BANNED)

- ‚ùå "This site blocks scrapers" ‚Üí without trying stealth/different approaches
- ‚ùå "Data isn't available" ‚Üí without checking multiple seasons/endpoints
- ‚ùå "We'll come back to this" ‚Üí without a specific retry plan and date
- ‚ùå "This platform is too complex" ‚Üí that's what Puppeteer + adapters are for
- ‚ùå Marking a state as "GS RANKS" when league data exists somewhere online
- ‚ùå Accepting empty results from a scrape without investigating why

---
